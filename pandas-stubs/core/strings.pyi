# pyright: strict
from collections.abc import (
    Callable,
    Sequence,
)
import re
from typing import (
    Any,
    Generic,
    Literal,
    TypeVar,
    overload,
)

import numpy as np
import numpy.typing as npt
import pandas as pd
from pandas import (
    DataFrame,
    Index,
    MultiIndex,
    Series,
)
from pandas.core.base import NoNewAttributesMixin

from pandas._libs.tslibs.nattype import NaTType
from pandas._typing import (
    JoinHow,
    Scalar,
    T,
    np_ndarray_bool,
)

# The _TS type is what is used for the result of str.split with expand=True
_TS = TypeVar("_TS", bound=DataFrame | MultiIndex)
# The _TS2 type is what is used for the result of str.split with expand=False
_TS2 = TypeVar("_TS2", bound=Series[list[str]] | Index[list[str]])
# The _TM type is what is used for the result of str.match
_TM = TypeVar("_TM", bound=Series[bool] | np_ndarray_bool)
# The _TI type is what is used for the result of str.index / str.find
_TI = TypeVar("_TI", bound=Series[int] | Index[int])
# The _TE type is what is used for the result of str.encode
_TE = TypeVar("_TE", bound=Series[bytes] | Index[bytes])
# The _TD type is what is used for the result of str.encode
_TD = TypeVar("_TD", bound=Series[str] | Index[str])

class StringMethods(NoNewAttributesMixin, Generic[T, _TS, _TM, _TS2, _TI, _TE, _TD]):
    def __init__(self, data: T) -> None: ...
    def __getitem__(self, key: slice | int) -> T: ...
    def __iter__(self) -> T: ...
    @overload
    def cat(
        self,
        *,
        sep: str,
        na_rep: str | None = ...,
        join: JoinHow = ...,
    ) -> str: ...
    @overload
    def cat(
        self,
        others: Literal[None] = ...,
        *,
        sep: str,
        na_rep: str | None = ...,
        join: JoinHow = ...,
    ) -> str: ...
    @overload
    def cat(
        self,
        others: (
            Series[str] | Index[str] | pd.DataFrame | npt.NDArray[np.str_] | list[str]
        ),
        sep: str = ...,
        na_rep: str | None = ...,
        join: JoinHow = ...,
    ) -> T: ...
    @overload
    def split(
        self, pat: str = ..., *, n: int = ..., expand: Literal[True], regex: bool = ...
    ) -> _TS: ...
    @overload
    def split(
        self,
        pat: str = ...,
        *,
        n: int = ...,
        expand: Literal[False] = ...,
        regex: bool = ...,
    ) -> _TS2: ...
    @overload
    def rsplit(self, pat: str = ..., *, n: int = ..., expand: Literal[True]) -> _TS: ...
    @overload
    def rsplit(
        self, pat: str = ..., *, n: int = ..., expand: Literal[False] = ...
    ) -> _TS2: ...
    @overload
    def partition(self, sep: str = ...) -> pd.DataFrame: ...
    @overload
    def partition(self, *, expand: Literal[True]) -> pd.DataFrame: ...
    @overload
    def partition(self, sep: str, expand: Literal[True]) -> pd.DataFrame: ...
    @overload
    def partition(
        self, sep: str, expand: Literal[False]
    ) -> pd.Series[type[object]]: ...
    @overload
    def partition(self, *, expand: Literal[False]) -> pd.Series[type[object]]: ...
    @overload
    def rpartition(self, sep: str = ...) -> pd.DataFrame: ...
    @overload
    def rpartition(self, *, expand: Literal[True]) -> pd.DataFrame: ...
    @overload
    def rpartition(self, sep: str, expand: Literal[True]) -> pd.DataFrame: ...
    @overload
    def rpartition(
        self, sep: str, expand: Literal[False]
    ) -> pd.Series[type[object]]: ...
    @overload
    def rpartition(self, *, expand: Literal[False]) -> pd.Series[type[object]]: ...
    def get(self, i: int) -> T: ...
    def join(self, sep: str) -> _TD: ...
    def contains(
        self,
        pat: str | re.Pattern[str],
        case: bool = ...,
        flags: int = ...,
        na: Scalar | NaTType | None = ...,
        regex: bool = ...,
    ) -> _TM: ...
    def match(
        self, pat: str, case: bool = ..., flags: int = ..., na: Any = ...
    ) -> _TM: ...
    def replace(
        self,
        pat: str,
        repl: str | Callable[[re.Match[str]], str],
        n: int = ...,
        case: bool | None = ...,
        flags: int = ...,
        regex: bool = ...,
    ) -> T: ...
    def repeat(self, repeats: int | Sequence[int]) -> T: ...
    def pad(
        self,
        width: int,
        side: Literal["left", "right", "both"] = ...,
        fillchar: str = ...,
    ) -> T: ...
    def center(self, width: int, fillchar: str = ...) -> T: ...
    def ljust(self, width: int, fillchar: str = ...) -> T: ...
    def rjust(self, width: int, fillchar: str = ...) -> T: ...
    def zfill(self, width: int) -> T: ...
    def slice(
        self, start: int | None = ..., stop: int | None = ..., step: int | None = ...
    ) -> T: ...
    def slice_replace(
        self, start: int | None = ..., stop: int | None = ..., repl: str | None = ...
    ) -> T: ...
    def decode(self, encoding: str, errors: str = ...) -> _TD: ...
    def encode(self, encoding: str, errors: str = ...) -> _TE: ...
    def strip(self, to_strip: str | None = ...) -> T: ...
    def lstrip(self, to_strip: str | None = ...) -> T: ...
    def rstrip(self, to_strip: str | None = ...) -> T: ...
    def wrap(
        self,
        width: int,
        expand_tabs: bool | None = ...,
        replace_whitespace: bool | None = ...,
        drop_whitespace: bool | None = ...,
        break_long_words: bool | None = ...,
        break_on_hyphens: bool | None = ...,
    ) -> T: ...
    def get_dummies(self, sep: str = ...) -> pd.DataFrame: ...
    def translate(self, table: dict[int, int | str | None] | None) -> T: ...
    def count(self, pat: str, flags: int = ...) -> _TI: ...
    def startswith(self, pat: str | tuple[str, ...], na: Any = ...) -> _TM: ...
    def endswith(self, pat: str | tuple[str, ...], na: Any = ...) -> _TM: ...
    def findall(self, pat: str, flags: int = ...) -> _TS2: ...
    @overload
    def extract(
        self, pat: str, flags: int = ..., *, expand: Literal[True] = ...
    ) -> pd.DataFrame: ...
    @overload
    def extract(
        self, pat: str, flags: int, expand: Literal[False]
    ) -> Series[type[object]]: ...
    @overload
    def extract(
        self, pat: str, flags: int = ..., *, expand: Literal[False]
    ) -> Series[type[object]]: ...
    def extractall(self, pat: str, flags: int = ...) -> pd.DataFrame: ...
    def find(self, sub: str, start: int = ..., end: int | None = ...) -> _TI: ...
    def rfind(self, sub: str, start: int = ..., end: int | None = ...) -> _TI: ...
    def normalize(self, form: Literal["NFC", "NFKC", "NFD", "NFKD"]) -> T: ...
    def index(self, sub: str, start: int = ..., end: int | None = ...) -> _TI: ...
    def rindex(self, sub: str, start: int = ..., end: int | None = ...) -> _TI: ...
    def len(self) -> _TI: ...
    def lower(self) -> T: ...
    def upper(self) -> T: ...
    def title(self) -> T: ...
    def capitalize(self) -> T: ...
    def swapcase(self) -> T: ...
    def casefold(self) -> T: ...
    def isalnum(self) -> _TM: ...
    def isalpha(self) -> _TM: ...
    def isdigit(self) -> _TM: ...
    def isspace(self) -> _TM: ...
    def islower(self) -> _TM: ...
    def isupper(self) -> _TM: ...
    def istitle(self) -> _TM: ...
    def isnumeric(self) -> _TM: ...
    def isdecimal(self) -> _TM: ...
    def fullmatch(
        self, pat: str, case: bool = ..., flags: int = ..., na: Any = ...
    ) -> _TM: ...
    def removeprefix(self, prefix: str) -> T: ...
    def removesuffix(self, suffix: str) -> T: ...
